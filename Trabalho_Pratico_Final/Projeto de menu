.data
bemvindo: .asciiz "BEM VINDO AO BUSCADOR DE PALAVRAS!\n"
menu: .asciiz "\nSelecione a opcao desejada:\n1)Buscar palavra\n2)Contar numero de ocorrencias de palavra\n3)Buscar trecho de texto\n4)Contar numero de ocorrencias de trecho de texto\n5)Buscar palavra sensivel a case\n6)Imprimir o texto\n7)Sair\n"
texto: .asciiz "um dois tres quatro cinco seis um dois um dois um "
#frases axuliares das subrotinas
sInvalido: .asciiz "\nOpcao errada\n"
pAceita: .asciiz "\nA palavra foi encontrada.\n"
pRejeita: .asciiz "\nA palavra nao foi encontrada.\n"
pATrecho: .asciiz "\nO trecho foi encontrado.\n"
pRTrecho: .asciiz "\nO trecho nao foi encontrado.\n"
sOcorrencias1: .asciiz "\nForam encontradas "
sOcorrencias2: .asciiz " ocorrencias da palavra.\n"
pErrada: .asciiz "\nVoce digitou uma palavra invalida.\n"
digite: .asciiz "\nDiga uma palavra: "
palavra: .space 20

.text
#imprimir bem vindo
la $a0, bemvindo
li $v0, 4
syscall
loop: #o loop sempre vai comecar imprimindo o menu
la $a0, menu
li $v0, 4
syscall
#ler um numero, interpretar esse numero
li $v0, 5
syscall 
move $t7, $v0 #salva o n√∫mero que vamos trabalhar em t7.
#interpretar o valor com beqs. O beq vai levar pra um r√≥tulo onde chama a subrotina. N√£o d√° pra botar beq $t7, 1, jal busca... ent√£o tem que mandar pra um r√≥tulo
beq $t7, 1 , op1
beq $t7, 2 , op2
beq $t7, 3 , op3
beq $t7, 4 , op4
beq $t7, 5 , op5
beq $t7, 6 , op6
beq $t7, 7 , sair
j invalido # se o usuario digitou uma opcao que nao tem,  um numero invalido, exibe mensagem

# ------------------------------------------- BUSCA PALAVRA --------------------------------------------------------

op1: 

jal askWord

identifica: 
beqz $t3, rejeita #se t3 for zero, cheguei no fim do texto. Sai do programa
lb $t3, 0($t0) #pega as letras do texto
lb $t4, 0($t1) #pega as letras da palavra
beq $t3, $t4, MesmaLetra #se as letras s√£o iguais...
beq $t3, 0x20, aceita # se eu encontrar um espa√ßo no texto, j√° achei o trecho

# lb $t5, 1($t1)
# beq $t5, 0x20, palavraErrada

#se chegar aqui, tem outra letra que n√£o √© igual, ent√£o procuro o pr√≥ximo espa√ßo.
addi $t0, $t0, 1 #incrementa as o contador pra voltar pro loop n√£o com o espa√ßo, mas com o que vem depois
j achaEspaco

MesmaLetra: #se as letras foram iguais...
#incremento os dois contadores e comparo de novo. T0 e T1 s√£o os endere√ßos. T3 e T4, as letras
addi $t0, $t0, 1 #texto 
addi $t1, $t1, 1 #palavra
lb $t3, 0($t0) #pega as letras do texto
lb $t4, 0($t1) #pega as letras da palavra
beq $t4, 0xa, verificaTexto #O √∫ltimo caracter da string de input √© o \n, 0xa. Se t4, que √© a letra da palavra, for \n, cheguei no fim da palavra, ent√£o ela est√° no texto
beq $t4, 0x20, palavraErrada #se eu achar um espa√ßo escrito na palavra, ela √© rejeitada
beq $t4, $t3 MesmaLetra #se depois de incrementar as letras ainda forem iguais, volta pro sub-loop e incrementa de novo
#se chegou at√© aqui, a palavra n√£o est√° na sequ√™ncia certa.
beq $t3, $zero, rejeita #se tem um espa√ßo no texto e n√£o tem na palavra, a palavra √© rejeitada
la $t1, palavra #reseta t1, t0 n√£o precisa resetar porque se a palavra n√£o estava aqui n√£o vai estar pra tr√°s
j achaEspaco # acho um espa√ßo pra poder seguir procurando a palavra

achaEspaco: beq $t3, 0x20, espaco # 20 √© o espa√ßo em hexa. Se for um espa√ßo, verifica as letras
beqz $t3, rejeita #caso o texto termine
addi $t0, $t0, 1 #incrementa as o contador de letras do texto
lb $t3, 0($t0) #pega a letra do texto
j achaEspaco #volta pro loop

espaco:
addi $t0, $t0, 1
j identifica

verificaTexto:
beq $t3, $zero, aceita
beq $t3, 0x20, aceita
j rejeita

rejeita: la $a0, pRejeita #S√≥ define o texto que vou escrever
j fim

palavraErrada: la $a0, pErrada #S√≥ define o texto que vou escrever
j fim

aceita: la $a0, pAceita #S√≥ define o texto que vou escrever
j fim

fim:
li $v0, 4
syscall #imprime a string definida anteriormente
j loop

# ------------------------------------ OCORRENCIA DA PALAVRA -----------------------------------------------------------------

op2: 

jal askWord

looping: beqz $t3, fim2 # se t3, contador de letras do texto, for zero, cheguei no fim do texto. Sai do programa
lb $t3, 0($t0) #pega as letras do texto
lb $t4, 0($t1) #pega as letras da palavra
beq $t3, $t4, MesmaLetra2 #se as letras sao iguais...
#sen√£o, incrementa o contador do texto
addi $t0, $t0, 1
j looping # e volta pro loop pra comparar a pr√≥xima letra.  

MesmaLetra2: #se as letras foram iguais...
#incremento os dois contadores e comparo de novo. T0 e T1 s√£o os √≠ndices. T3 e T4, as letras
addi $t0, $t0, 1 #texto 
addi $t1, $t1, 1 #palavra
lb $t3, 0($t0) #pega as letras do texto
lb $t4, 0($t1) #pega as letras da palavra
beq $t4, 0xa, verificaTexto2 #O √∫ltimo caracter da string de input √© o \n, 0xa. Se t4, que √© a letra da palavra, for \n, cheguei no fim da palavra, ent√£o encontrei ela no texto
beq $t4, 0x20, palavraInvalida2 #se a palavra tiver um espaco, nao e considerada palavra e a contagem de ocorrencias e zero
beq $t4, $t3 MesmaLetra2 #se depois de incrementar as letras ainda forem iguais, volta pro sub-loop e incrementa de novo
#se chegou at√© aqui, a palavra n√£o est√° na sequ√™ncia certa.
#posso procurar pelo pr√≥ximo espa√ßo e ent√£o voltar pro loop pra tentar de novo
la $t1, palavra #reseta t1, t0 n√£o precisa resetar porque se a palavra n√£o estava aqui n√£o vai estar pra tr√°s
j achaEspaco2 #assim, volto a verificar a partir do pr√≥ximo espa√ßo.

achaEspaco2: beq $t3, 0x20, espaco2 # 20 e o espaco em hexa. Se for um espaco, volta a ver se as letras sao iguais
beqz $t3, fim2 #caso o texto termine
addi $t0, $t0, 1 #incrementa as o contador de letras do texto
lb $t3, 0($t0) #pega a letra do texto pra fazer a compara√ß√£o
j achaEspaco2

espaco2:
addi $t0, $t0, 1
j looping

verificaTexto2:
beq $t3, $zero, fim2
beq $t3, 0x20, incrementa2
j achaEspaco2

incrementa2: addi $t5, $t5, 1 #incrementa o contador de ocorr√™ncias
la $t1, palavra # reseta a palavra, pra usar ela pra encontrar outra
j espaco2 #volta pro loop pra continuar contando

palavraInvalida2:
li $v0, 4
la $a0, pErrada
syscall
j finish

fim2:
li $v0, 4 # imprimir string
la $a0, sOcorrencias1 # primeira parte do texto
syscall #imprime primeira parte
li $v0, 1 #pra imprimir um inteiro
move $a0, $t5 #copia o conte√∫do do contador pro a0 
syscall #imprime n√∫mero
li $v0, 4 # imprimir string
la $a0, sOcorrencias2 # segunda parte do texto
syscall #imprime segunda parte

finish:
move $t5, $zero		# Reseta o valor do contador de ocorrencia

j loop

# ----------------------------- Busca trecho ----------------------------------

op3: jal askWord
loop3: beqz $t3, rejeita3 #se t3 for zero, cheguei no fim do texto. Sai do programa
beqz $t4, rejeita3 #se t4 for igual a zero, sai do programa.
lb $t3, 0($t0) #pega as letras do texto
lb $t4, 0($t1) #pega as letras da palavra
beq $t3, $t4, MesmaLetra3 #se as letras s„o iguais...
#sen„o, incrementa o contador do texto
addi $t0, $t0, 1
j loop3 # e volta pro loop pra comparar a prÛxima letra.  

MesmaLetra3: #se as letras foram iguais...
#incremento os dois contadores e comparo de novo. T0 e T1 s„o os endereÁos. T3 e T4, as letras
addi $t0, $t0, 1 #texto 
addi $t1, $t1, 1 #palavra
lb $t3, 0($t0) #pega as letras do texto
lb $t4, 0($t1) #pega as letras da palavra
beq $t4, 0xa, aceita3 #O ˙ltimo caracter da string de input È o \n, 0xa. Se t4, que È a letra da palavra, for \n, cheguei no fim da palavra, ent„o ela est· no texto
beq $t4, $t3 MesmaLetra3 #se depois de incrementar as letras ainda forem iguais, volta pro sub-loop e incrementa de novo
#se chegou atÈ aqui, a palavra n„o est· na sequÍncia certa.
la $t1, palavra #reseta t1, t0 n„o precisa resetar porque se a palavra n„o estava aqui n„o vai estar pra tr·s
j loop3

rejeita3: la $a0, pRTrecho #SÛ define o texto que vou escrever
j fim3

aceita3: la $a0, pATrecho #SÛ define o texto que vou escrever
j fim3

fim3:
li $v0, 4
syscall #imprime a string de aceita ou rejeita definida anteriormente
j loop

 # ------------------------------ Ocorrencia de trecho --------------------------
 
op4: 
jal askWord
loop4: beqz $t3, fim4 #se t3, contador de letras do texto, for zero, cheguei no fim do texto. Sai do programa
lb $t3, 0($t0) #pega as letras do texto
lb $t4, 0($t1) #pega as letras da palavra
beq $t3, $t4, MesmaLetra4 #se as letras s„o iguais...
#sen„o, incrementa o contador do texto
addi $t0, $t0, 1
j loop4 # e volta pro loop pra comparar a prÛxima letra.  

MesmaLetra4: #se as letras foram iguais...
#incremento os dois contadores e comparo de novo. T0 e T1 s„o os endereÁos. T3 e T4, as letras
addi $t0, $t0, 1 #texto 
addi $t1, $t1, 1 #palavra
lb $t3, 0($t0) #pega as letras do texto
lb $t4, 0($t1) #pega as letras da palavra
beq $t4, 0xa, incrementa4 #O ˙ltimo caracter da string de input È o \n, 0xa. Se t4, que È a letra da palavra, for \n, cheguei no fim da palavra, ent„o encontrei ela no texto
beq $t4, $t3 MesmaLetra4 #se depois de incrementar as letras ainda forem iguais, volta pro sub-loop e incrementa de novo
#se chegou atÈ aqui, a palavra n„o est· na sequÍncia certa.
la $t1, palavra #reseta t1, t0 n„o precisa resetar porque se a palavra n„o estava aqui n„o vai estar pra tr·s
j loop4

incrementa4: addi $t5, $t5, 1 #incrementa o contador de ocorrÍncias
la $t1, palavra # reseta a palavra
j loop4 #volta pro loop pra continuar contando

fim4:
li $v0, 4 # imprimir string
la $a0, sOcorrencias1 #primeira parte do texto
syscall #imprime primeira parte
li $v0, 1 #pra imprimir um inteiro
move $a0, $t5 #copia o conte˙do do contador pro a0 
syscall #imprime n˙mero
li $v0, 4 # imprimir string
la $a0, sOcorrencias2 #segunda parte do texto
syscall #imprime segunda parte
move $t5, $zero
j loop


op5: #jal SenCase
j loop
op6: jal Imprime #imprimir o texto
j loop

sair: #fim da execu√ß√£o
li $v0, 10#c√≥digo para terminar a execu√ß√£o
syscall#termina a execu√ß√£o do programa.

Imprime: la $a0, texto #imprime o texto
li $v0, 4
syscall 
jr $ra #volta pro menu

invalido: la $a0, sInvalido #imprime mensagem de input inv√°lido
li $v0, 4
syscall 
j loop #volta pro menu

askWord:
la $a0, digite
li $v0, 4
syscall
li $v0, 8 #codigo para ler uma string
#Endereco onde vai ser armazenada a palavra se passa em a0 e o tamanho em a1
la $a0, palavra #onde guardar a palavra
li $a1, 20 # tamanho da palavra
syscall # a string
la $t0, texto #t0 guarda o inicio do texto.
la $t1, palavra #t1 guarda o inicio da palavra
#t3,t4 e t5 s√£o os contadores da fun√ß√£o, inicializo eles aqui. Pra n√£o dar problema.
li $t3, 1
li $t4, 1

jr $ra
